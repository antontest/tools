#! /bin/bash
#    Name  : mkct
# Function : copy the template for c programing
#    Time  : 2015-06-02 19:03:25

filename=""
arg_flag=0

io=0
opt=0
fdir=0
proc=0
pthrd=0
sig=0
sck=0
sysinf=0
tm=0

function print_usage()
{
    echo -e "\e[1;31m#-------------------Shell Usage------------------#"
    echo "Usage  : $(basename $0) [options] script-name"
    echo "Options: "
    echo "     -h,--help        show usage of shell"
    echo "     -a,--args        c template add get_opt function"
    echo "     -f,--file-name   c file name"
    echo -e "#-------------------Shell Usage-------------------#\e[0m"
}

function parser_args()
{
	TEMP=`getopt -o ahfio --long help,args,file,fdir,io,opt,proc,pthread,sig,sock,sysinfo,time -n 'mkct' -- "$@"`

    if [ $? != 0 ] ; then echo "Terminating..." >&2 ; exit 1 ; fi

    # Note the quotes around `$TEMP': they are essential!
    # set 会重新排列参数的顺序，也就是改变$1,$2...$n的值，这些值在getopt中重新排列过了
    eval set -- "$TEMP"

    #经过getopt的处理，下面处理具体选项。
    while test -n "$1" ; do
        case "$1" in
            -h|--help)  print_usage $@  ; shift ;;
            -a|--args)  arg_flag=1      ; shift ;;
            -f|--file)  filename=$2     ; shift 2;;
            -i|--io)    io=1            ; shift ;;
            -o|--opt)   opt=1           ; shift ;;
            --fdir)     fdir=1          ; shift ;;
            --proc)     proc=1          ; shift ;;
            --pthread)    pthrd=1         ; shift ;;
            --sig)      sig=1           ; shift ;;
            --sock)      sck=1           ; shift ;;
            --sysinfo)   sysinf=1        ; shift ;;
            --time)       tm=1            ; shift ;;
            --) shift ; break ;;
            *) echo "Internal error!" ; exit 1 ;;
        esac
    done

    if test -z "$filename" ; then
        filename=$@
    fi

    return 0
}

function add_head()
{
    if test $io -eq 1 ; then
        echo -e "" >> $@ ; cat $C_HEAD_TMP_PATH/io.h >> $@
    fi    
    if test $opt -eq 1 ; then
        echo -e "" >> $@ ; cat $C_HEAD_TMP_PATH/opt.h >> $@
    fi    
    if test $fdir -eq 1 ; then
        echo -e "" >> $@ ; cat $C_HEAD_TMP_PATH/fdir.h >> $@
    fi    
    if test $proc -eq 1 ; then
        echo -e "" >> $@ ; cat $C_HEAD_TMP_PATH/proc.h >> $@
    fi    
    if test $pthrd -eq 1 ; then
        echo -e "" >> $@ ; cat $C_HEAD_TMP_PATH/pthrd.h >> $@
    fi    
    if test $sig -eq 1 ; then
        echo -e "" >> $@ ; cat $C_HEAD_TMP_PATH/sig.h >> $@
    fi    
    if test $sck -eq 1 ; then
        echo -e "" >> $@ ; cat $C_HEAD_TMP_PATH/sck.h >> $@
    fi    
    if test $sysinf -eq 1 ; then
        echo -e "" >> $@ ; cat $C_HEAD_TMP_PATH/sysinf.h >> $@
    fi    
    if test $tm -eq 1 ; then
        echo -e "" >> $@ ; cat $C_HEAD_TMP_PATH/tm.h >> $@
    fi    

    return 0
}

#parse parameters
parser_args $@

# get c files's name from cmd lin
if test -z "$filename" 
then
    filename=$(basename $(pwd)).c
fi

# loop to create c file
for name in $filename
do
    len=${#name}
    let len--

    if test ${name:$len:1} != 'c' -o $len -eq 0 -o ${name:$[len-1]:1} != '.'; then
        name=$name.c
    fi

    if test ! -f $name ; then
        cat $C_HEAD_TMP_PATH/usual.h >> $name
        add_head $name
        if test $arg_flag -eq 1 ; then
            cat $C_SRC_TMP_PATH/main.c >> $name
            pro_name=${name/\.c/}
            sed -i "/%%process_name%%/Is/%%process_name%%/$pro_name/g" $name
        else
            cat $C_SRC_TMP_PATH/main-sample.c >> $name
        fi
    fi
done
